#include "Sexp.hpp"

namespace mc {

  Value VariableNode::eval() {
    return *(SymbolTable::getValue(id));
  }

  ExprNode::~ExprNode() {
    for (Sexp* sexp : sexps) {
      delete sexp;
    }
  }

  Value ExprNode::eval() {
    
    Value ret(Type::ERROR);
    if (sexps.empty()) {
      ret.str_val = "Expression is empty";
      return ret;
    }
    
    Array<Value> args(sexps.size() - 1);
    for (u32 n=1; n<sexps.size(); ++n) {
      args.push_back(sexps[n]->eval());
    }
    
    Value func(sexps.front()->eval());
    if (func.type != Type::FUNCTION) {
      ret.str_val = "First element in expression is not callable";
      return ret;
    }
    
    ret = func.func_val->call(args);
    return ret;
  }
  
  String ValueNode::toString(String spaces) {
    return spaces + "value { " + to_string(value) + " }";
  }

  String VariableNode::toString(String spaces) {
    return spaces + "variable {\n" +
      spaces + " name: " + name + "\n" +
      spaces + " value: " + to_string(eval()) + "\n" +
      spaces + "}";
  }

  String ExprNode::toString(String spaces) {
    String ret = spaces + "expr {\n";
    for (Sexp* sexp : sexps) {
      ret += spaces + sexp->toString(spaces + " ") + "\n";
    }
    ret += spaces + "}";
    return ret;
  }

  String to_string(Sexp* sexp) {
    assert(sexp);
    return sexp->toString("");
  }
  
}
